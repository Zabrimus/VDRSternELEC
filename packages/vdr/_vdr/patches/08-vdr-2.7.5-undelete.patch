diff -ru8bBwd a/config.c b/config.c
--- a/config.c	2026-01-21 21:19:59.000000000 +0100
+++ b/config.c	2026-01-24 10:23:55.898797705 +0100
@@ -431,16 +431,18 @@
   UseSubtitle = 1;
   UseVps = 0;
   VpsMargin = 120;
   RecordingDirs = 1;
   FoldersInTimerMenu = 1;
   AlwaysSortFoldersFirst = 1;
   DefaultSortModeRec = rsmTime;
   RecSortingDirection = rsdAscending;
+  UndeleteTimeOut = 0;
+  ButtonFirst = 0;
   NumberKeysForChars = 1;
   ColorKey0 = 0;
   ColorKey1 = 1;
   ColorKey2 = 2;
   ColorKey3 = 3;
   VideoDisplayFormat = 1;
   VideoFormat = 0;
   UpdateChannels = 5;
@@ -662,16 +664,18 @@
   else if (!strcasecmp(Name, "UseSubtitle"))         UseSubtitle        = atoi(Value);
   else if (!strcasecmp(Name, "UseVps"))              UseVps             = atoi(Value);
   else if (!strcasecmp(Name, "VpsMargin"))           VpsMargin          = atoi(Value);
   else if (!strcasecmp(Name, "RecordingDirs"))       RecordingDirs      = atoi(Value);
   else if (!strcasecmp(Name, "FoldersInTimerMenu"))  FoldersInTimerMenu = atoi(Value);
   else if (!strcasecmp(Name, "AlwaysSortFoldersFirst")) AlwaysSortFoldersFirst = atoi(Value);
   else if (!strcasecmp(Name, "RecSortingDirection")) RecSortingDirection= atoi(Value);
   else if (!strcasecmp(Name, "DefaultSortModeRec"))  DefaultSortModeRec = atoi(Value);
+  else if (!strcasecmp(Name, "UndeleteTimeOut"))     UndeleteTimeOut    = atoi(Value);
+  else if (!strcasecmp(Name, "ButtonFirst"))         ButtonFirst        = atoi(Value);
   else if (!strcasecmp(Name, "NumberKeysForChars"))  NumberKeysForChars = atoi(Value);
   else if (!strcasecmp(Name, "ColorKey0"))           ColorKey0          = atoi(Value);
   else if (!strcasecmp(Name, "ColorKey1"))           ColorKey1          = atoi(Value);
   else if (!strcasecmp(Name, "ColorKey2"))           ColorKey2          = atoi(Value);
   else if (!strcasecmp(Name, "ColorKey3"))           ColorKey3          = atoi(Value);
   else if (!strcasecmp(Name, "VideoDisplayFormat"))  VideoDisplayFormat = atoi(Value);
   else if (!strcasecmp(Name, "VideoFormat"))         VideoFormat        = atoi(Value);
   else if (!strcasecmp(Name, "UpdateChannels"))      UpdateChannels     = atoi(Value);
@@ -797,16 +801,18 @@
   Store("UseSubtitle",        UseSubtitle);
   Store("UseVps",             UseVps);
   Store("VpsMargin",          VpsMargin);
   Store("RecordingDirs",      RecordingDirs);
   Store("FoldersInTimerMenu", FoldersInTimerMenu);
   Store("AlwaysSortFoldersFirst", AlwaysSortFoldersFirst);
   Store("RecSortingDirection",RecSortingDirection);
   Store("DefaultSortModeRec", DefaultSortModeRec);
+  Store("UndeleteTimeOut",    UndeleteTimeOut);
+  Store("ButtonFirst",        ButtonFirst);
   Store("NumberKeysForChars", NumberKeysForChars);
   Store("ColorKey0",          ColorKey0);
   Store("ColorKey1",          ColorKey1);
   Store("ColorKey2",          ColorKey2);
   Store("ColorKey3",          ColorKey3);
   Store("VideoDisplayFormat", VideoDisplayFormat);
   Store("VideoFormat",        VideoFormat);
   Store("UpdateChannels",     UpdateChannels);
diff -ru8bBwd a/config.h b/config.h
--- a/config.h	2026-01-21 21:19:59.000000000 +0100
+++ b/config.h	2026-01-24 10:23:55.898797705 +0100
@@ -321,16 +321,18 @@
   int UseSubtitle;
   int UseVps;
   int VpsMargin;
   int RecordingDirs;
   int FoldersInTimerMenu;
   int AlwaysSortFoldersFirst;
   int DefaultSortModeRec;
   int RecSortingDirection;
+  int UndeleteTimeOut;
+  int ButtonFirst;
   int NumberKeysForChars;
   int ColorKey0, ColorKey1, ColorKey2, ColorKey3;
   int VideoDisplayFormat;
   int VideoFormat;
   int UpdateChannels;
   int UseDolbyDigital;
   int ChannelInfoPos;
   int ChannelInfoTime;
diff -ru8bBwd a/menu.c b/menu.c
--- a/menu.c	2026-01-21 21:19:59.000000000 +0100
+++ b/menu.c	2026-01-24 10:23:55.898797705 +0100
@@ -2915,24 +2915,25 @@
 // --- cMenuRecording --------------------------------------------------------
 
 class cMenuRecording : public cOsdMenu {
 private:
   const cRecording *recording;
   cString originalFileName;
   cStateKey recordingsStateKey;
   bool withButtons;
+  bool deletedRecording;
   bool RefreshRecording(void);
 public:
-  cMenuRecording(const cRecording *Recording, bool WithButtons = false);
+  cMenuRecording(const cRecording *Recording, bool WithButtons = false, bool DeletedRecording = false);
   virtual void Display(void) override;
   virtual eOSState ProcessKey(eKeys Key) override;
 };
 
-cMenuRecording::cMenuRecording(const cRecording *Recording, bool WithButtons)
+cMenuRecording::cMenuRecording(const cRecording *Recording, bool WithButtons, bool DeletedRecording)
 :cOsdMenu(tr("Recording info"))
 {
   SetMenuCategory(mcRecordingInfo);
   if (cRecordings::GetRecordingsRead(recordingsStateKey)) // initializes recordingsStateKey, so we don't call Display() unnecessarily
      recordingsStateKey.Remove();
   recording = Recording;
   originalFileName = recording->FileName();
   withButtons = WithButtons;
@@ -3464,27 +3465,104 @@
               Skins.Message(mtError, tr("Error while permanently deleting recording!"));
            recordingsStateKey.Remove();
            }
         }
      }
   return osContinue;
 }
 
+eOSState cMenuRecordings::Undelete(void)
+{
+#define RECEXT       ".rec"
+#define DELEXT       ".del"
+  if (HasSubMenu() || Count() == 0)
+     return osContinue;
+  if (cMenuRecordingItem *ri = (cMenuRecordingItem *)Get(Current())) {
+     if (ri->IsDirectory())
+        return osContinue;
+     else {
+        if (Interface->Confirm(tr("Restore recording?"))) {
+           cRecording *Recording = ((cRecording *)ri->Recording());
+           if (Recording) {
+              if (Recording->Undelete()) {
+                 cOsdMenu::Del(Current());
+                 if (cRecordings *DeletedRecordings = cRecordings::GetDeletedRecordingsWrite(recordingsStateKey)) { // write access is necessary for sorting!
+                    DeletedRecordings->Del(Recording);
+                    recordingsStateKey.Remove(true);
+                    char *NewName = strdup(Recording->FileName());
+                    char *ext = strrchr(NewName, '.');
+                    if (ext && strcmp(ext, DELEXT) == 0) {
+                       strncpy(ext, RECEXT, strlen(ext));
+                       LOCK_RECORDINGS_WRITE;
+                       Recordings->AddByName(NewName);
+                       cVideoDiskUsage::ForceCheck();
+                       }
+                    }
+                 else
+                    Skins.Message(mtError, tr("Error while restoring recording!"));
+                 Display();
+                 if (!Count())
+                    return osUserRecEmpty;
+                 return osUserRecRemoved;
+                 }
+              else
+                 Skins.Message(mtError, tr("Error while restoring recording!"));
+              }
+           }
+        }
+     }
+  return osContinue;
+}
+
+eOSState cMenuRecordings::Erase(void)
+{
+  dsyslog ("%s %s %d\n", __FILE__, __func__,  __LINE__);
+  if (HasSubMenu() || Count() == 0)
+     return osContinue;
+  if (cMenuRecordingItem *ri = (cMenuRecordingItem *)Get(Current())) {
+     if (ri->IsDirectory())
+        return osContinue;
+     else {
+        if (Interface->Confirm(tr("Delete recording?"))) {
+           cRecording *recording = ((cRecording *)ri->Recording());
+           if (recording) {
+              if (recording->Remove()) {
+                 cOsdMenu::Del(Current());
+                 if (cRecordings *DeletedRecordings = cRecordings::GetDeletedRecordingsWrite(recordingsStateKey)) { // write access is necessary for sorting!
+                    DeletedRecordings->Del(recording);
+                    recordingsStateKey.Remove(true);
+                    }
+                 else
+                    Skins.Message(mtError, tr("Error while removing recording!"));
+                 Display();
+                 if (!Count())
+                    return osUserRecEmpty;
+                 return osUserRecRemoved;
+                 }
+              else
+                 Skins.Message(mtError, tr("Error while removing recording!"));
+              }
+           }
+        }
+     }
+  return osContinue;
+}
+
 eOSState cMenuRecordings::Info(void)
 {
   if (HasSubMenu() || Count() == 0)
      return osContinue;
   if (cMenuRecordingItem *ri = (cMenuRecordingItem *)Get(Current())) {
      if (ri->IsDirectory()) {
         if (!delRecMenu)
            return AddSubMenu(new cMenuPathEdit(cString(ri->Recording()->Name(), strchrn(ri->Recording()->Name(), FOLDERDELIMCHAR, ri->Level() + 1))));
         }
      else
-        return AddSubMenu(new cMenuRecording(ri->Recording(), true));
+        return AddSubMenu(new cMenuRecording(ri->Recording(), true, delRecMenu));
      }
   return osContinue;
 }
 
 eOSState cMenuRecordings::Commands(eKeys Key)
 {
   if (HasSubMenu() || Count() == 0)
      return osContinue;
@@ -3624,16 +3702,17 @@
 // --- cMenuSetupOSD ---------------------------------------------------------
 
 class cMenuSetupOSD : public cMenuSetupBase {
 private:
   const char *useSmallFontTexts[3];
   const char *recSortModeTexts[2];
   const char *recSortDirTexts[2];
   const char *keyColorTexts[4];
+  const char *buttonFirst[2];
   int osdLanguageIndex;
   int numSkins;
   int originalSkinIndex;
   int skinIndex;
   const char **skinDescriptions;
   cThemes themes;
   int originalThemeIndex;
   int themeIndex;
@@ -3679,16 +3758,18 @@
       skinDescriptions[Skin->Index()] = Skin->Description();
   useSmallFontTexts[0] = tr("never");
   useSmallFontTexts[1] = tr("skin dependent");
   useSmallFontTexts[2] = tr("always");
   recSortModeTexts[0] = tr("by name");
   recSortModeTexts[1] = tr("by time");
   recSortDirTexts[0] = tr("ascending");
   recSortDirTexts[1] = tr("descending");
+  buttonFirst[0] = tr("Button$UNDELETE");
+  buttonFirst[1] = tr("Key$Commands");
   keyColorTexts[0] = tr("Key$Red");
   keyColorTexts[1] = tr("Key$Green");
   keyColorTexts[2] = tr("Key$Yellow");
   keyColorTexts[3] = tr("Key$Blue");
   Clear();
   SetSection(tr("OSD"));
   Add(new cMenuEditStraItem(tr("Setup.OSD$Language"),               &osdLanguageIndex, I18nNumLanguagesWithLocale(), &I18nLanguages()->At(0)));
   Add(new cMenuEditStraItem(tr("Setup.OSD$Skin"),                   &skinIndex, numSkins, skinDescriptions));
@@ -3714,16 +3795,19 @@
   Add(new cMenuEditBoolItem(tr("Setup.OSD$Scroll pages"),           &data.MenuScrollPage));
   Add(new cMenuEditBoolItem(tr("Setup.OSD$Scroll wraps"),           &data.MenuScrollWrap));
   Add(new cMenuEditBoolItem(tr("Setup.OSD$Menu key closes"),        &data.MenuKeyCloses));
   Add(new cMenuEditBoolItem(tr("Setup.OSD$Recording directories"),  &data.RecordingDirs));
   Add(new cMenuEditBoolItem(tr("Setup.OSD$Folders in timer menu"),  &data.FoldersInTimerMenu));
   Add(new cMenuEditBoolItem(tr("Setup.OSD$Always sort folders first"), &data.AlwaysSortFoldersFirst));
   Add(new cMenuEditStraItem(tr("Setup.OSD$Default sort mode for recordings"), &data.DefaultSortModeRec, 2, recSortModeTexts));
   Add(new cMenuEditStraItem(tr("Setup.OSD$Sorting direction for recordings"), &data.RecSortingDirection, 2, recSortDirTexts));
+  Add(new cMenuEditIntItem( tr("Setup.OSD$Red button UNDELETE timeout (s)"), &data.UndeleteTimeOut, 0, 10, tr("off")));
+  if (data.UndeleteTimeOut)
+  Add(new cMenuEditStraItem(tr("Setup.OSD$Displayed first (UNDELETE or Commands)"), &data.ButtonFirst, 2, buttonFirst));
   Add(new cMenuEditBoolItem(tr("Setup.OSD$Number keys for characters"), &data.NumberKeysForChars));
   Add(new cMenuEditStraItem(tr("Setup.OSD$Color key 0"),            &data.ColorKey0, 4, keyColorTexts));
   Add(new cMenuEditStraItem(tr("Setup.OSD$Color key 1"),            &data.ColorKey1, 4, keyColorTexts));
   Add(new cMenuEditStraItem(tr("Setup.OSD$Color key 2"),            &data.ColorKey2, 4, keyColorTexts));
   Add(new cMenuEditStraItem(tr("Setup.OSD$Color key 3"),            &data.ColorKey3, 4, keyColorTexts));
   SetCurrent(Get(current));
   Display();
 }
@@ -3763,22 +3847,23 @@
      if (data.AlwaysSortFoldersFirst != Setup.AlwaysSortFoldersFirst || data.RecordingDirs != Setup.RecordingDirs || data.RecSortingDirection != Setup.RecSortingDirection) {
         LOCK_RECORDINGS_WRITE;
         Recordings->ClearSortNames();
         }
      }
 
   int oldSkinIndex = skinIndex;
   int oldOsdLanguageIndex = osdLanguageIndex;
+  int oldUndeleteTimeOut = data.UndeleteTimeOut;
   eOSState state = cMenuSetupBase::ProcessKey(Key);
 
   if (ModifiedAppearance)
      cOsdProvider::UpdateOsdSize(true);
 
-  if (osdLanguageIndex != oldOsdLanguageIndex || skinIndex != oldSkinIndex) {
+  if (osdLanguageIndex != oldOsdLanguageIndex || skinIndex != oldSkinIndex || data.UndeleteTimeOut != oldUndeleteTimeOut) {
      strn0cpy(data.OSDLanguage, I18nLocale(osdLanguageIndex), sizeof(data.OSDLanguage));
      int OriginalOSDLanguage = I18nCurrentLanguage();
      I18nSetLanguage(osdLanguageIndex);
 
      cSkin *Skin = Skins.Get(skinIndex);
      if (Skin) {
         char *d = themes.NumThemes() ? strdup(themes.Descriptions()[themeIndex]) : NULL;
         themes.Load(Skin->Name());
diff -ru8bBwd a/menu.h b/menu.h
--- a/menu.h	2026-01-21 21:19:59.000000000 +0100
+++ b/menu.h	2026-01-24 10:42:16.886813280 +0100
@@ -225,16 +225,18 @@
   eOSState AdjustTitle(eOSState State);
   eOSState Play(void);
   eOSState Rewind(void);
   eOSState Delete(void);
   eOSState Restore(void);
   eOSState Purge(void);
   eOSState Info(void);
   eOSState Sort(void);
+  eOSState Undelete(void);
+  eOSState Erase(void);
   eOSState Commands(eKeys Key = kNone);
   void SetDeleted(const char *FileName);
 protected:
   cString DirectoryName(void);
 public:
   cMenuRecordings(const char *Base = NULL, int Level = 0, bool OpenSubMenus = false, const cRecordingFilter *Filter = NULL, bool DelRecMenu = false);
   ~cMenuRecordings();
   virtual eOSState ProcessKey(eKeys Key) override;
diff -ru8bBwd a/po/de_DE.po b/po/de_DE.po
--- a/po/de_DE.po	2026-01-21 21:19:59.000000000 +0100
+++ b/po/de_DE.po	2026-01-24 10:47:17.520442612 +0100
@@ -938,16 +938,19 @@
 msgstr "Aufzeichnung endgültig löschen?"
 
 msgid "Are you sure? This can't be undone!"
 msgstr "Sind Sie sicher? Das lässt sich nicht rückgängig machen!"
 
 msgid "Error while permanently deleting recording!"
 msgstr "Fehler beim endgültigen Löschen der Aufzeichnung!"
 
+msgid "Error while removing recording!"
+msgstr "Fehler beim Löschen der Aufnahme!"
+
 msgid "Recording commands"
 msgstr "Befehle für Aufzeichnungen"
 
 msgid "never"
 msgstr "nie"
 
 msgid "skin dependent"
 msgstr "je nach Oberfläche"
@@ -1055,16 +1058,22 @@
 msgstr "Verzeichnisse immer zuerst einsortieren"
 
 msgid "Setup.OSD$Default sort mode for recordings"
 msgstr "Standard-Sortierung für Aufzeichnungen"
 
 msgid "Setup.OSD$Sorting direction for recordings"
 msgstr "Sortierreihenfolge für Aufzeichnungen"
 
+msgid "Setup.OSD$Red button UNDELETE timeout (s)"
+msgstr ""
+
+msgid "Setup.OSD$Displayed first (UNDELETE or Commands)"
+msgstr "Wird zuerst angezeigt (UNDELETE oder Befehle)"
+
 msgid "Setup.OSD$Number keys for characters"
 msgstr "Nummerntasten für Zeichen"
 
 msgid "Setup.OSD$Color key 0"
 msgstr "Farbtaste 0"
 
 msgid "Setup.OSD$Color key 1"
 msgstr "Farbtaste 1"
