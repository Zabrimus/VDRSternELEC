--- a/recording.c	2022/12/01 12:47:33	5.20
+++ b/recording.c	2023/02/15 14:59:25
@@ -312,23 +312,31 @@
            if (safe_write(f, &Index, sizeof(Index)) < 0)
               LOG_ERROR_STR(fileName);
            close(f);
-           LOCK_RECORDINGS_WRITE;
-           Recordings->ResetResume(fileName);
-           return true;
            }
+        else
+           return false;
         }
      else {
         FILE *f = fopen(fileName, "w");
         if (f) {
            fprintf(f, "I %d\n", Index);
            fclose(f);
-           LOCK_RECORDINGS_WRITE;
-           Recordings->ResetResume(fileName);
            }
-        else
+        else {
            LOG_ERROR_STR(fileName);
-        return true;
+           return false;
+           }
         }
+     // Not using LOCK_RECORDINGS_WRITE here, because we might already hold a lock in cRecordingsHandler::Action()
+     // and end up here if an editing process is canceled while the edited recording is being replayed. The worst
+     // that can happen if we don't get this lock here is that the resume info in the Recordings list is not updated,
+     // but that doesn't matter because the recording is deleted, anyway.
+     cStateKey StateKey;
+     if (cRecordings *Recordings = cRecordings::GetRecordingsWrite(StateKey, 1)) {
+        Recordings->ResetResume(fileName);
+        StateKey.Remove();
+        }
+     return true;
      }
   return false;
 }
@@ -1889,8 +1897,8 @@
   void SetCanceled(void) { usage |= ruCanceled; }
   const char *FileNameSrc(void) const { return fileNameSrc; }
   const char *FileNameDst(void) const { return fileNameDst; }
-  bool Active(void);
-  void Cleanup(void);
+  bool Active(cRecordings *Recordings);
+  void Cleanup(cRecordings *Recordings);
   };
 
 cRecordingsHandlerEntry::cRecordingsHandlerEntry(int Usage, const char *FileNameSrc, const char *FileNameDst)
@@ -1921,7 +1929,7 @@
   return u;
 }
 
-bool cRecordingsHandlerEntry::Active(void)
+bool cRecordingsHandlerEntry::Active(cRecordings *Recordings)
 {
   if ((usage & ruCanceled) != 0)
      return false;
@@ -1941,7 +1949,6 @@
      copier = NULL;
      }
   // Now check if there is something to start:
-  LOCK_RECORDINGS_WRITE;
   if ((Usage() & ruPending) != 0) {
      if ((Usage() & ruCut) != 0) {
         cutter = new cCutter(FileNameSrc());
@@ -1954,6 +1961,7 @@
         copier->Start();
         }
      ClearPending();
+     Recordings->SetModified(); // to trigger a state change
      return true;
      }
   // We're done:
@@ -1966,11 +1974,12 @@
         Recordings->DelByName(Recording.FileName());
         }
      }
+  Recordings->SetModified(); // to trigger a state change
   Recordings->TouchUpdate();
   return false;
 }
 
-void cRecordingsHandlerEntry::Cleanup(void)
+void cRecordingsHandlerEntry::Cleanup(cRecordings *Recordings)
 {
   if ((usage & ruCut)) {          // this was a cut operation...
      if (cutter                   // ...which had not yet ended...
@@ -1979,7 +1988,6 @@
            delete cutter;
            cutter = NULL;
            }
-        LOCK_RECORDINGS_WRITE;
         cVideoDirectory::RemoveVideoFile(fileNameDst);
         Recordings->DelByName(fileNameDst);
         }
@@ -1992,7 +2000,6 @@
         delete copier;
         copier = NULL;
         }
-     LOCK_RECORDINGS_WRITE;
      cVideoDirectory::RemoveVideoFile(fileNameDst);
      if ((usage & ruMove) != 0)
         Recordings->AddByName(fileNameSrc);
@@ -2021,11 +2028,13 @@
   while (Running()) {
         bool Sleep = false;
         {
+          LOCK_RECORDINGS_WRITE;
+          Recordings->SetExplicitModify();
           cMutexLock MutexLock(&mutex);
           if (cRecordingsHandlerEntry *r = operations.First()) {
-             if (!r->Active()) {
+             if (!r->Active(Recordings)) {
                 error |= r->Error();
-                r->Cleanup();
+                r->Cleanup(Recordings);
                 operations.Del(r);
                 }
              else
